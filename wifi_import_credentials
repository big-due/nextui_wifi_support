#!/bin/sh
#
# NextUI WiFi 'wifi_import_credentials' for tg5040
# Reads wifi credentials from /mnt/SDCARD/wifi.txt and updates /etc/wifi/wpa_supplicant.conf
# Version 0.0.1
#
# Exit codes
# 0 - Success
# 1 - Failure

WPA_SUPPLICANT_CONF="/etc/wifi/wpa_supplicant.conf"
WPA_SOCKET_DIR="/etc/wifi/sockets"
WIFI_TXT="/mnt/SDCARD/wifi.txt"
DEFAULT_HIDDEN_PREFIX="_hidden_"

# Global variables for credential handling
network_name=""
network_name_hidden=0
network_password=""
network_password_hashed=0


# ********** awk scripts **********

PARSE_NETWORK_ENTRY_AWK='
function trim(str) {
    gsub(/^[ \t]+|[ \t]+$/, "", str)
    return str
}

function unquote(str) {
    str = trim(str)
    if (substr(str, 1, 1) == "\"" && substr(str, length(str), 1) == "\"")
        return substr(str, 2, length(str) - 2)
    return str
}

BEGIN { FS = ":" }
{
    name = trim($1)
    # Join remaining fields with colon in case password contains colons
    password = ""
    for (i=2; i<=NF; i++) {
        if (i>2) password = password ":"
        password = password $i
    }
    password = unquote(password)
    printf("%s|%s", name, password)
}'

UPDATE_NETWORK_AWK='
BEGIN {
    found = in_block = is_target = has_psk = has_scan_ssid = 0
}

/^\s*network=\{/ {
    in_block = 1
    is_target = has_mgmt = has_psk = has_scan_ssid = 0
}

in_block && /^\s*ssid="/ {
    if ($0 ~ "ssid=\"" ssid_sub "\"") {
        is_target = found = 1
    }
}

in_block && is_target && /^\s*psk=/ {
    has_psk = 1
    if (psk_sub == "") {
        next
    } else {
        sub(/psk=.*/, "psk=" psk_sub)
    }
}

in_block && is_target && /^\s*key_mgmt=/ {
    sub(/key_mgmt=.*/, "key_mgmt=" mgmt_sub)
    has_mgmt = 1
}

in_block && is_target && /^\s*scan_ssid=/ {
    sub(/scan_ssid=.*/, "scan_ssid=" scan_ssid_sub)
    has_scan_ssid = 1
}

in_block && /^\s*\}/ {
    if (is_target) {
        if (!has_psk && psk_sub != "") {
            print "\tpsk=" psk_sub
        }
        if (!has_mgmt) {
            print "\tkey_mgmt=" mgmt_sub
        }
        if (!has_scan_ssid) {
            print "\tscan_ssid=" scan_ssid_sub
        }
    }
    in_block = is_target = 0
}

{ print }

END {
    if (!found) {
        exit 1
    }
}'

REMOVE_NETWORK_AWK='
BEGIN {
    in_block = 0
    remove_block = 0
    matched = 0
    block = ""
}

/^\s*network=\{/ {
    in_block = 1
    remove_block = 0
    block = $0 ORS
    next
}

in_block {
    block = block $0 ORS

    if ($0 ~ "ssid=\\\"" ssid "\\\"") {
        remove_block = 1
        matched = 1
    }

    if (/^\s*\}/) {
        getline nextline
        if (!remove_block) {
            printf "%s", block
            if (nextline ~ /^$/) print nextline
        } else {
            if (nextline !~ /^$/ && nextline != "") print nextline
        }
        in_block = 0
        block = ""
    }
    next
}
{
    print
}

END {
    if (!matched) {
        exit 1
    }
}'

# ********** wpa_supplicant.conf templates **********

# Template for wpa_supplicant.conf
WPA_CONF_TEMPLATE="ctrl_interface=DIR
disable_scan_offload=1
update_config=1
wowlan_triggers=any"

# Template for network configuration
NETWORK_CONF_TEMPLATE="network={
        ssid=\"SSID_SUB\"
        psk=PSK_SUB
        key_mgmt=MGMT_SUB
        scan_ssid=HIDDEN_SUB
}"

# ********** Helper Functions **********

# Escape special characters in a string
escape_string() {
    printf "%s" "$1" | sed 's/\\/\\\\/g; s/\//\\\//g; s/\[/\\[/g; s/\]/\\]/g; s/\^/\\^/g; s/\$/\\$/g; s/\./\\./g; s/\*/\\*/g; s/\+/\\+/g; s/?/\\?/g; s/{/\\{/g; s/}/\\}/g; s/(/\\(/g; s/)/\\)/g; s/|/\\|/g; s/&/\\&/g'
}

# Validate hex PSK (64 chars, all hex)
validate_hex_psk() {
    [ ${#1} -eq 64 ] && echo "$1" | grep -q '^[0-9a-fA-F]\+$'
}

# Validate plaintext password (8-63 chars)
validate_plaintext_password() {
    local length=${#1}
    [ "$length" -ge 8 ] && [ "$length" -le 63 ]
}

# Validate SSID (1-32 bytes)
validate_ssid() {
    local length=${#1}
    [ "$length" -gt 0 ] && [ "$length" -le 32 ]
}

# Strip hidden network prefix, then unquote
strip_network_hidden_prefix() {
    local network_name="$1"
    local prefix="${2:-$DEFAULT_HIDDEN_PREFIX}"
    echo "${network_name#$prefix}"
}

# Check if wpa_supplicant.conf exists and has correct format
validate_wpa_conf() {
    [ -f "$WPA_SUPPLICANT_CONF" ] && grep -q "ctrl_interface=${WPA_SOCKET_DIR}" "$WPA_SUPPLICANT_CONF"
}

# Create new wpa_supplicant.conf file
create_wpa_conf() {
    local template="${WPA_CONF_TEMPLATE/DIR/$WPA_SOCKET_DIR}"
    echo "$template" > "$WPA_SUPPLICANT_CONF" && echo "" >> "$WPA_SUPPLICANT_CONF"
}

# Backup wpa_supplicant.conf
backup_wpa_conf() {
    local backup_file="${WPA_SUPPLICANT_CONF}.bak"
    cp "$WPA_SUPPLICANT_CONF" "$backup_file" && echo "$backup_file"
}

# ********** wpa_suplicant.conf handling functions **********

# Reconfigure wpa_supplicant after config changes
reconfigure_wpa_supplicant() {
    # Skip if wpa_supplicant is not running with our config
    pgrep -f "wpa_supplicant.*$WPA_SUPPLICANT_CONF" >/dev/null 2>&1 || return 0
    # Try to reconfigure if wpa_cli is available
    if command -v wpa_cli >/dev/null 2>&1; then
        wpa_cli -p "$WPA_SOCKET_DIR" reconfigure >/dev/null 2>&1
    fi
    return 0
}

# Check if network exists in config
network_exists() {
    local escaped_name=$(escape_string "$1")
    grep -E "^\s*ssid=\"$escaped_name\"\s*$" "$WPA_SUPPLICANT_CONF" | grep -q -v "^\s*#"
}

# Add a new network to config
add_network() {
    local network_name="$1"
    local password="$2"
    local is_hidden="${3:-0}"
    local is_hashed="${4:-0}"
    local formatted_psk=""
    local key_mgmt="WPA-PSK"
    
    [ -z "$network_name" ] && return 1
    
    # Handle open networks (empty password)
    if [ -z "$password" ]; then
        key_mgmt="NONE"
        password=""
    elif [ "$is_hashed" -eq 1 ]; then
        # Hex PSK
        formatted_psk="$password"
    else
        # Plaintext password
        formatted_psk="\"$password\""
    fi
    
    # Create network configuration
    local network_conf="${NETWORK_CONF_TEMPLATE}"
    network_conf="${network_conf/SSID_SUB/$network_name}"
    network_conf="${network_conf/MGMT_SUB/$key_mgmt}"
    if [ -z "$formatted_psk" ]; then
        network_conf=$(echo "$network_conf" | sed '/psk=/d')
    else
        network_conf="${network_conf/PSK_SUB/$formatted_psk}"
    fi
    network_conf="${network_conf/HIDDEN_SUB/$is_hidden}"
    
    # Add to config file
    echo "$network_conf" >> "$WPA_SUPPLICANT_CONF" &&
    echo "" >> "$WPA_SUPPLICANT_CONF"
}

# Update existing network
update_network() {
    local network_name="$1"
    local password="$2"
    local is_hidden="${3:-0}"
    local is_hashed="${4:-0}"
    local temp_file="${WPA_SUPPLICANT_CONF}.tmp"
    local formatted_psk=""
    local key_mgmt="WPA-PSK"
    
    [ -z "$network_name" ] && return 1
    
    # Handle password format
    if [ -z "$password" ]; then
        key_mgmt="NONE"
        password=""
    elif [ "$is_hashed" -eq 1 ]; then
        formatted_psk="$password"
    else
        formatted_psk="\"$password\""
    fi
    
    # Use awk to update the network
    local escaped_name=$(escape_string "$network_name")
    awk -v ssid_sub="$escaped_name" \
        -v mgmt_sub="$key_mgmt" \
        -v psk_sub="$formatted_psk" \
        -v scan_ssid_sub="$is_hidden" \
        "$UPDATE_NETWORK_AWK" "$WPA_SUPPLICANT_CONF" > "$temp_file" &&
    mv "$temp_file" "$WPA_SUPPLICANT_CONF"
}

# Remove a network
remove_network() {
    local network_name="$1"
    local temp_file="${WPA_SUPPLICANT_CONF}.tmp"
    
    [ -z "$network_name" ] && return 1
    
    local escaped_name=$(escape_string "$network_name")
    awk -v ssid="$escaped_name" "$REMOVE_NETWORK_AWK" "$WPA_SUPPLICANT_CONF" > "$temp_file" &&
    mv "$temp_file" "$WPA_SUPPLICANT_CONF"
}

# ********** Credential Processing Functions **********

# Parse a network entry from wifi.txt
parse_network_entry() {
    local line="$1"
    local result=""
    
    # Reset global variables
    network_name=""
    network_name_hidden=0
    network_password=""
    network_password_hashed=0
    
    # Skip empty lines and comments
    [ -z "$line" ] || [ "${line#\#}" != "$line" ] && return 1
    
    # Parse with awk
    result=$(echo "$line" | awk "$PARSE_NETWORK_ENTRY_AWK")
    [ -z "$result" ] && return 1
    
    # Extract name and password
    network_name=$(echo "$result" | cut -d'|' -f1)
    network_password=$(echo "$result" | cut -d'|' -f2)
    
    [ -z "$network_name" ] && return 1
    # Check for hidden network prefix
    local stripped_name=$(strip_network_hidden_prefix "$network_name")
    if [ "$network_name" != "$stripped_name" ]; then
        network_name="$stripped_name"
        network_name_hidden=1
    fi
    # remove surrounding single or double quotes from network name
    network_name=$(echo "$network_name" | sed -e 's/^"\(.*\)"$/\1/' -e "s/^'\(.*\)'$/\1/")
    
    # Validate SSID
    validate_ssid "$network_name" || return 1
    
    # Validate password
    if [ -z "$network_password" ]; then
        # Empty password (open network or removal)
        return 0
    elif validate_hex_psk "$network_password"; then
        # Valid hex PSK
        network_password_hashed=1
        return 0
    elif validate_plaintext_password "$network_password"; then
        # Valid plaintext password
        return 0
    fi
    
    # Invalid password format
    network_name=""
    network_password=""
    network_name_hidden=0
    network_password_hashed=0
    return 1
}

# Process wifi.txt and update config
process_credentials() {
    local credentials_file="${1:-$WIFI_TXT}"
    
    echo "Processing credentials from $credentials_file"
    [ ! -f "$credentials_file" ] || [ ! -r "$credentials_file" ] && return 1
    
    local error=0
    
    while IFS= read -r line || [ -n "$line" ]; do
        # Skip empty lines and comments
        [ -z "$line" ] || [ "${line#\#}" != "$line" ] && continue
        
        # Parse the line into global variables
        if ! parse_network_entry "$line"; then
            continue
        fi
        
        if [ -z "$network_password" ]; then
            # Empty password means remove the network
            if network_exists "$network_name"; then
                echo "Removing network: $network_name"
                remove_network "$network_name" || { echo "Failed to remove network $network_name"; error=1; }
            fi
        else
            if network_exists "$network_name"; then
                echo "Updating network: $network_name"
                update_network "$network_name" "$network_password" "$network_name_hidden" "$network_password_hashed" || \
                { echo "Failed to update network $network_name"  >&2 ; error=1; }
            else
                echo "Adding network: $network_name"
                add_network "$network_name" "$network_password" "$network_name_hidden" "$network_password_hashed" || \
                { echo "Failed to add network $network_name"  >&2 ; error=1; }
            fi
        fi
    done < "$credentials_file"
    
    echo "Credential processing completed with error code: $error"
    return "$error"
}


# ********** WiFi Import Credentials **********

echo "Starting WiFi Import Credentials..." > /dev/console

# If no wpa_supplicant.conf, create a new one
[ -f "$WPA_SUPPLICANT_CONF" ] || create_wpa_conf

# Check for wifi.txt file
[ -f "$WIFI_TXT" ] || exit 0

echo "Processing credentials from $WIFI_TXT"
# Backup or create wpa_supplicant.conf
backup_file=""
if ! validate_wpa_conf; then
    [ -f "$WPA_SUPPLICANT_CONF" ] && backup_file=$(backup_wpa_conf)
    create_wpa_conf || exit 1
else
    backup_file=$(backup_wpa_conf)
fi

# Process credentials and clean up
if process_credentials "$WIFI_TXT"; then
    echo "Credentials processed successfully, reconfiguring wpa_supplicant..."
    reconfigure_wpa_supplicant 
    rm -f "$WIFI_TXT"
    [ -n "$backup_file" ] && [ -f "$backup_file" ] && rm -f "$backup_file"
    exit 0
else
    echo "Failed to process credentials, restoring backup..."
    # Restore backup on failure
    [ -n "$backup_file" ] && [ -f "$backup_file" ] && cp "$backup_file" "$WPA_SUPPLICANT_CONF" && rm -f "$backup_file"
    exit 1
fi
